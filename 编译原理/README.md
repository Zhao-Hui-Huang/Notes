编译原理

# 术语

句型、句子

>
> 文法G[S]，若$S \overset{*}{\Rightarrow} x$，则称$x$是文法$G$的**句型**。
>
> 文法G[S]，若$S \overset{*}{\Rightarrow} x $，且，$x \in V_{T}^{*}$则称$x$是文法$G$的**句子**。
>
> *程序就是句子*

规范推导、规范句型

> 最左（最右）推导：在推导的任何一步$\alpha \overset {*}{\Rightarrow } \beta​$，其中$\alpha​$、$\beta ​$是句型，都是对$\alpha ​$中的最左（右）非终结符进行替换。
>
> 最右推导被称为**规范推导**。
>
> 由**规范推导**所得的句型称为**规范句型**。

短语、直接短语、句柄

>
> 文法G[S]，$S \overset{*}{\Rightarrow} \alpha A \delta$ 且，$A \overset{+}{\Rightarrow} \beta$，则称$\beta$是句型$\alpha \beta \delta$相对于非终结符A的**短语**。
>
> 若有$A \Rightarrow \beta$，则称$\beta$是句型$\alpha \beta \delta$相对于规则$A \Rightarrow \beta$的**直接短语**。
>
> 一个句型的最左直接短语称为该句型的**句柄**。

活前缀、可归前缀

> 文法G[S]，若$S \underset{r}{\overset{*}{\Rightarrow}} \alpha A\omega \underset{r}{\Rightarrow} \alpha\beta\omega$是文法$G$的拓广文法$G^{'} $ 的一个规范推导，符号串$\gamma$是$\alpha\beta $的前缀，则称$\gamma $是$G$的一个**活前缀**。（$\alpha,\beta \in V^{+}, \omega \in V^{*}_{T}, A \in V_{N}$，若$\gamma $是含句柄的活前缀，则称$\gamma $是文法的**可归前缀**。
>
> A为当前句型$\alpha A\omega ​$中最右边的非终结符。
>
> 句柄是$\gamma $的后缀，即活前缀中最长的一个。
>
> 活前缀的右端不会超过该句型句柄的末端。

活前缀与产生式

> 每个活前缀与一个产生式相关联，该可归前缀的每个活前缀与这个产生式相关联。活前缀反映已经得到的产生式的多大一部分，还期望得到什么，可归前缀表明已经得到产生式的全部，应该归约了。
>

# LR分析

## 拓广文法

在原文法中增加产生式$S^{'} \rightarrow S $，$S$为$G$的开始符号，所得的文法为$G$的拓广文法，以$G^{'}$表示，$S^{'}$为新的开始符号。

> 拓文文法的目的是为了对某些右部含有开始符号的文法，在归约过程中能分清是否已经归约到文法的最初开始，还是在文法右部出现的开始符号。
>

# 两类分析方式： 

> 自上而下分析法：从文法的开始符号出发，反复使用文法的产生式，寻找与输入符号串匹配的推导，或者说，为输入串寻找一个最左推导。
>
> 自下而上分析法：从输入串开始，进行归约，直至归约到开始符号

# LL vs LR

> At a high level, the difference between LL parsing and LR parsing is that **LL parsers** begin at the start symbol and try to apply productions to arrive at the target string, whereas **LR parsers** begin at the target string and try to arrive back at the start symbol.
>
> An **LL parse** is a **l**eft-to-right, **l**eftmost derivation. That is, we consider the input symbols from the left to the right and attempt to construct a leftmost derivation. This is done by beginning at the start symbol and repeatedly expanding out the leftmost nonterminal until we arrive at the target string. An **LR  parse** is a **l**eft-to-right, **r**ightmost derivation, meaning that we scan from the left to right and attempt to construct a rightmost derivation. The parser continuously picks a substring of the input and attempts to reverse it back to a nonterminal.
>
> **LR parsers** come in many flavors (LR(0), SLR(1), LALR(1), LR(1), IELR(1), GLR(0), etc.) and are far more powerful. They also tend to have much more complex and are almost always generated by tools like `yacc` or `bison`. **LL parsers** also come in many flavors (including LL(*), which is used by the [`ANTLR`](http://www.antlr.org/) tool), though in practice LL(1) is the most-widely used.



几种文法之间的关系

[https://stackoverflow.com/questions/5975741/what-is-the-difference-between-ll-and-lr-parsing](https://stackoverflow.com/questions/5975741/what-is-the-difference-between-ll-and-lr-parsing)

[LL and LR Parsing Demystified](http://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html)

[https://en.wikipedia.org/wiki/LL_parser](https://en.wikipedia.org/wiki/LL_parser)

[https://en.wikipedia.org/wiki/LR_parser](https://en.wikipedia.org/wiki/LR_parser)

