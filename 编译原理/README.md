编译原理

# 术语

句型、句子

>
> 文法G[S]，若$S \overset{*}{\Rightarrow} x$，则称$x$是文法$G$的**句型**。
>
> 文法G[S]，若$S \overset{*}{\Rightarrow} x $，且，$x \in V_{T}^{*}$则称$x$是文法$G$的**句子**。
>
> *程序就是句子*

规范推导、规范句型

> 最左（最右）推导：在推导的任何一步$\alpha \overset {*}{\Rightarrow } \beta​$，其中$\alpha​$、$\beta ​$是句型，都是对$\alpha ​$中的最左（右）非终结符进行替换。
>
> 最右推导被称为**规范推导**。
>
> 由**规范推导**所得的句型称为**规范句型**。

短语、直接短语、句柄

>
> 文法G[S]，$S \overset{*}{\Rightarrow} \alpha A \delta$ 且，$A \overset{+}{\Rightarrow} \beta$，则称$\beta$是句型$\alpha \beta \delta$相对于非终结符A的**短语**。
>
> 若有$A \Rightarrow \beta$，则称$\beta$是句型$\alpha \beta \delta$相对于规则$A \Rightarrow \beta$的**直接短语**。
>
> 一个句型的最左直接短语称为该句型的**句柄**。

活前缀、可归前缀

> 文法G[S]，若$S \underset{r}{\overset{*}{\Rightarrow}} \alpha A\omega \underset{r}{\Rightarrow} \alpha\beta\omega$是文法$G$的拓广文法$G^{'} $ 的一个规范推导，符号串$\gamma$是$\alpha\beta $的前缀，则称$\gamma $是$G$的一个**活前缀**。（$\alpha,\beta \in V^{+}, \omega \in V^{*}_{T}, A \in V_{N}$，若$\gamma $是含句柄的活前缀，则称$\gamma $是文法的**可归前缀**。
>
> A为当前句型$\alpha A\omega ​$中最右边的非终结符。
>
> 句柄是$\gamma $的后缀，即活前缀中最长的一个。
>
> 活前缀的右端不会超过该句型句柄的末端。

活前缀与产生式

> 每个活前缀与一个产生式相关联，该可归前缀的每个活前缀与这个产生式相关联。活前缀反映已经得到的产生式的多大一部分，还期望得到什么，可归前缀表明已经得到产生式的全部，应该归约了。
>

# LR分析

## 拓广文法

在原文法中增加产生式$S^{'} \rightarrow S $，$S$为$G$的开始符号，所得的文法为$G$的拓广文法，以$G^{'}$表示，$S^{'}$为新的开始符号。

> 拓文文法的目的是为了对某些右部含有开始符号的文法，在归约过程中能分清是否已经归约到文法的最初开始，还是在文法右部出现的开始符号。

## 项

> LR分析器通过维护一些状态，用这些**状态**表明我们在语法分析过程中所处的位置，从而做出移入－归约的决定。这些**状态**代表了**项**的集合。
>
> 一个文法G的一个LR（0）**项**是G的一个产生式再加上一个位于它的体中某处的点。

项集

项集族

项集的闭包

内核项与非内核项



LR(0)

查看下一个符号(Token)

SLR(1)

增加搜索符（只对归约项目有意义）

LR(1)

合并同心集

LALR(1)



SLR分析器：功能较弱、实用价值不高；规模与LR(0)相同、易实现

LR分析器：功能强大、实用价值高；规模远大于LR(0)、实现代价高

LALR分析器：功能介于SLR和LR(k)之间、实用价值高；规模与LR(0)相同、实现难

通常，同一个文法的LR(1)状态数要比LR(0)的多，而LALR(1)状态数与LR(0)的相同。 

# CUP

每一个生成的解析器包含三个生成的类。

`sym`类包含一系列的整形常量。

`parser`源文件包含两个类的定义

- 公开的`parser`类，实现真实的解析器,它是`java_cup.runtime.lr_parser`的子类，`lr_parser`类实现了LR解析器通用的表驱动的构架。`parser`在提供产生式表、action表和goto表。
- 非公开的类`CUP$action`，封装用户在文法中定义的所有action，还有来自`action code`声明中的代码。除了用户提供的代码，这个类也包含一个方法`CUP$do_action`，在这个方法中包含了一个大的switch语句来选择和执行各种用户提供的代码段。通常，所有以`CUP$`前缀开始的命名都是保留给CUP生成代码内部使用的。



将分析栈与符号栈合二为一了。



[http://www2.cs.tum.edu/projects/cup/docs.php#intro](http://www2.cs.tum.edu/projects/cup/docs.php#intro)

# 两类分析方式

> 自上而下分析法：从文法的开始符号出发，反复使用文法的产生式，寻找与输入符号串匹配的推导，或者说，为输入串寻找一个最左推导。
>
> 自下而上分析法：从输入串开始，进行归约，直至归约到开始符号

# LL vs LR

> At a high level, the difference between LL parsing and LR parsing is that **LL parsers** begin at the start symbol and try to apply productions to arrive at the target string, whereas **LR parsers** begin at the target string and try to arrive back at the start symbol.
>
> An **LL parse** is a **l**eft-to-right, **l**eftmost derivation. That is, we consider the input symbols from the left to the right and attempt to construct a leftmost derivation. This is done by beginning at the start symbol and repeatedly expanding out the leftmost nonterminal until we arrive at the target string. An **LR  parse** is a **l**eft-to-right, **r**ightmost derivation, meaning that we scan from the left to right and attempt to construct a rightmost derivation. The parser continuously picks a substring of the input and attempts to reverse it back to a nonterminal.
>
> **LR parsers** come in many flavors (LR(0), SLR(1), LALR(1), LR(1), IELR(1), GLR(0), etc.) and are far more powerful. They also tend to have much more complex and are almost always generated by tools like `yacc` or `bison`. **LL parsers** also come in many flavors (including LL(*), which is used by the [`ANTLR`](http://www.antlr.org/) tool), though in practice LL(1) is the most-widely used.



几种文法之间的关系

[https://stackoverflow.com/questions/5975741/what-is-the-difference-between-ll-and-lr-parsing](https://stackoverflow.com/questions/5975741/what-is-the-difference-between-ll-and-lr-parsing)

[LL and LR Parsing Demystified](http://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html)

[https://en.wikipedia.org/wiki/LL_parser](https://en.wikipedia.org/wiki/LL_parser)

[https://en.wikipedia.org/wiki/LR_parser](https://en.wikipedia.org/wiki/LR_parser)

